#!/bin/bash

getdiskID() {
    pool="$1"
    diskidnum="$2"
    total_discs="$3"
    
    menu_read() {
        diskidmenu_loc="/tmp/diskidmenu.txt"
        ls -la /dev/disk/by-id | awk '{ print $9, $11 }' | sed -e '1,3d' | grep -v "part\|CD-ROM" > "$diskidmenu_loc"
        
        echo "Please enter Disk ID option for disk $diskidnum of $total_discs on $pool pool."
        nl "$diskidmenu_loc"
        count="$(wc -l "$diskidmenu_loc" | cut -f 1 -d' ')"
        n=""
        while true; do
            read -r -p 'Select option: ' n
            if [ -n "$n" ] && [ "$n" -eq "$n" ] 2>/dev/null && [ "$n" -gt 0 ] && [ "$n" -le "$count" ]; then
                break
            fi
        done
        DISKID="$(sed -n "${n}p" "$diskidmenu_loc" | awk '{ print $1 }')"
        printf "%s\n\n" "Option number $n selected: '$DISKID'"
    }
    menu_read
    
    ## error check
    errchk="$(find /dev/disk/by-id -maxdepth 1 -mindepth 1 -name "$DISKID")"
    if [ -z "$errchk" ]; then
        echo "Disk ID not found. Exiting."
        exit 1
    fi
        
    errchk="$(grep "$DISKID" "/tmp/diskid_check_${pool}.txt" 2>/dev/null || true)"
    if [ -n "$errchk" ]; then
        echo "Disk ID has already been entered. Exiting."
        exit 1
    fi
    
    printf "%s\n" "$DISKID" >> "/tmp/diskid_check_${pool}.txt"
}

getdiskID_pool() {
    pool="$1"

    ## Check that number of disks meets minimum number for selected topology.
    topology_min_disk_check "$pool"

    echo "Carefully enter the ID of the disk(s) YOU WANT TO DESTROY in the next step to ensure no data is accidentally lost."
    
    ## Create temp file to check for duplicated disk ID entry.
    true > "/tmp/diskid_check_${pool}.txt"

    topology_pool_pointer="topology_$pool"
    eval "topology_val=\$${topology_pool_pointer}"
    
    disks_pointer="disks_${pool}"
    eval "disks_val=\$${disks_pointer}"

    case "$topology_val" in
        single)
            echo "The $pool pool disk topology is a single disk."
            getdiskID "$pool" "1" "1"
        ;;
        mirror|raid0|raidz*)
            echo "The $pool pool disk topology is $topology_val with $disks_val disks."
            diskidnum="1"
            while [ "$diskidnum" -le "$disks_val" ]; do
                getdiskID "$pool" "$diskidnum" "$disks_val"
                diskidnum=$(( diskidnum + 1 ))
            done
        ;;
        *)
            echo "Pool topology not recognised. Check pool topology variable."
            exit 1
        ;;
    esac
}

clear_partition_table() {
    pool="$1" # root or data
    while IFS= read -r diskidnum; do
        DRIVE="/dev/disk/by-id/$diskidnum"
        echo "Performing aggressive destructive preparation on disk ${diskidnum}."
        
        # Unmounting (umount): Identify and forcibly unmount all partitions
        echo "Unmounting all partitions on $DRIVE..."
        grep "^$DRIVE" /proc/mounts | cut -f2 -d" " | sort -r | xargs -r umount -fl || true
        
        # Swap Deactivation (swapoff): Disable all swap space
        echo "Deactivating swap..."
        swapoff -a || true

        # Stop RAID arrays
        echo "Stopping RAID arrays..."
        mdadm --stop --scan || true

        # Clear device-mapper entries (LVM, LUKS, etc.)
        echo "Clearing device-mapper entries..."
        dmsetup remove_all --force || true
        
        # Signature Wiping (wipefs): Delete all legacy filesystem signatures
        echo "Wiping filesystem signatures..."
        wipefs --all --force "$DRIVE"
        
        # MBR/GPT Overwrite (dd): Physically destroy partition table and boot sector
        echo "Overwriting first 10MB of the drive..."
        dd if=/dev/zero of="$DRIVE" bs=1M count=10 status=progress conv=fsync
        
        # Wipe end of disk (backup GPT header)
        echo "Wiping end of the drive..."
        disk_size=$(blockdev --getsize64 "$DRIVE")
        dd if=/dev/zero of="$DRIVE" bs=1M count=10 seek=$(( (disk_size / 1024 / 1024) - 10 )) status=progress conv=fsync || true

        echo "Settling udev events..."
        udevadm settle
        
        echo "Clearing partition table with sgdisk..."
        sgdisk --zap-all "$DRIVE"

        echo "Forcing kernel to reread partition table..."
        blockdev --rereadpt "$DRIVE" || true
        partprobe "$DRIVE" || true
    done < "/tmp/diskid_check_${pool}.txt"
}

partitionsFunc() {
    while IFS= read -r diskidnum; do
        DRIVE="/dev/disk/by-id/${diskidnum}"
        echo "Creating partitions on disk ${diskidnum} using sequential layout."
        
        # Label Initialization
        parted -s "$DRIVE" mklabel gpt
        
        CURRENT=1 # Start at 1MB for alignment
        
        add_part() {
            local name="$1"
            local size_raw="$2"
            local type="$3"
            local size_mib
            local end
            
            if [ "$size_raw" = "0" ] || [ "$size_raw" = "max" ]; then
                end="100%"
            else
                # Parse suffix and convert to MiB
                if [[ "$size_raw" =~ ^([0-9]+)([GgMmTt])$ ]]; then
                    local val="${BASH_REMATCH[1]}"
                    local unit="${BASH_REMATCH[2]}"
                    case "${unit,,}" in
                        g) size_mib=$((val * 1024)) ;;
                        t) size_mib=$((val * 1024 * 1024)) ;;
                        m) size_mib=$val ;;
                    esac
                elif [[ "$size_raw" =~ ^[0-9]+$ ]]; then
                    size_mib="$size_raw"
                else
                    echo "Error: Invalid partition size format: $size_raw"
                    exit 1
                fi
                end="$((CURRENT + size_mib))MiB"
            fi
            
            echo "Adding partition: $name ($CURRENT MiB to $end)"
            parted -s "$DRIVE" mkpart "$name" "${CURRENT}MiB" "$end"
            
            if [ "$end" != "100%" ]; then
                CURRENT=$((CURRENT + size_mib))
            fi
        }

        # 1: EFI System Partition (512MB)
        add_part "EFI" 512 "EF00"
        
        # 2: ZFS Root (Size from config)
        add_part "ZFS" "$zfs_root_size" "BF01"
        
        # 3: Unmanaged Space (Remainder)
        add_part "DATA" "max" "8300"
        
    done < "/tmp/diskid_check_root.txt"
    partprobe
    sleep 2
}
