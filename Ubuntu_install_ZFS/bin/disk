#!/bin/bash

getdiskID() {
    pool="$1"
    diskidnum="$2"
    total_discs="$3"
    
    menu_read() {
        diskidmenu_loc="/tmp/diskidmenu.txt"
        ls -la /dev/disk/by-id | awk '{ print $9, $11 }' | sed -e '1,3d' | grep -v "part\|CD-ROM" > "$diskidmenu_loc"
        
        user_action_banner "Select Disk ID option for disk $diskidnum of $total_discs on $pool pool."
        nl "$diskidmenu_loc"
        count="$(wc -l "$diskidmenu_loc" | cut -f 1 -d' ')"
        n=""
        while true; do
            read -r -p 'Select option: ' n
            if [ -n "$n" ] && [ "$n" -eq "$n" ] 2>/dev/null && [ "$n" -gt 0 ] && [ "$n" -le "$count" ]; then
                break
            fi
        done
        DISKID="$(sed -n "${n}p" "$diskidmenu_loc" | awk '{ print $1 }')"
        printf "%s\n\n" "Option number $n selected: '$DISKID'"
    }
    menu_read
    
    ## error check
    errchk="$(find /dev/disk/by-id -maxdepth 1 -mindepth 1 -name "$DISKID")"
    if [ -z "$errchk" ]; then
        echo "Disk ID not found. Exiting."
        exit 1
    fi
        
    errchk="$(grep "$DISKID" "/tmp/diskid_check_${pool}.txt" 2>/dev/null || true)"
    if [ -n "$errchk" ]; then
        echo "Disk ID has already been entered. Exiting."
        exit 1
    fi
    
    printf "%s\n" "$DISKID" >> "/tmp/diskid_check_${pool}.txt"
}

getdiskID_pool() {
    pool="$1"

    ## Check that number of disks meets minimum number for selected topology.
    topology_min_disk_check "$pool"

    user_action_banner "Carefully select the disk(s) YOU WANT TO DESTROY.\n  Ensure no data is accidentally lost!"
    
    ## Create temp file to check for duplicated disk ID entry.
    true > "/tmp/diskid_check_${pool}.txt"

    topology_pool_pointer="topology_$pool"
    eval "topology_val=\$${topology_pool_pointer}"
    
    disks_pointer="disks_${pool}"
    eval "disks_val=\$${disks_pointer}"

    case "$topology_val" in
        single)
            echo "The $pool pool disk topology is a single disk."
            getdiskID "$pool" "1" "1"
        ;;
        mirror|raid0|raidz*)
            echo "The $pool pool disk topology is $topology_val with $disks_val disks."
            diskidnum="1"
            while [ "$diskidnum" -le "$disks_val" ]; do
                getdiskID "$pool" "$diskidnum" "$disks_val"
                diskidnum=$(( diskidnum + 1 ))
            done
        ;;
        *)
            echo "Pool topology not recognised. Check pool topology variable."
            exit 1
        ;;
    esac
}

clear_partition_table() {
    pool="$1" # root or data
    while IFS= read -r diskidnum; do
        DRIVE="/dev/disk/by-id/$diskidnum"
        echo "Performing aggressive destructive preparation on disk ${diskidnum}."
        
        # Unmounting (umount): Identify and forcibly unmount all partitions
        echo "Unmounting all partitions on $DRIVE..."
        grep "^$DRIVE" /proc/mounts | cut -f2 -d" " | sort -r | xargs -r umount -fl || true
        
        # Swap Deactivation (swapoff): Disable all swap space
        echo "Deactivating swap..."
        swapoff -a || true

        # Stop RAID arrays
        echo "Stopping RAID arrays..."
        mdadm --stop --scan || true

        # Clear device-mapper entries (LVM, LUKS, etc.)
        echo "Clearing device-mapper entries..."
        dmsetup remove_all --force || true
        
        # Signature Wiping (wipefs): Delete all legacy filesystem signatures
        echo "Wiping filesystem signatures..."
        wipefs --all --force "$DRIVE"
        
        # MBR/GPT Overwrite (dd): Physically destroy partition table and boot sector
        echo "Overwriting first 10MB of the drive..."
        dd if=/dev/zero of="$DRIVE" bs=1M count=10 status=progress conv=fsync
        
        # Wipe end of disk (backup GPT header)
        echo "Wiping end of the drive..."
        disk_size=$(blockdev --getsize64 "$DRIVE")
        dd if=/dev/zero of="$DRIVE" bs=1M count=10 seek=$(( (disk_size / 1024 / 1024) - 10 )) status=progress conv=fsync || true

        echo "Settling udev events..."
        udevadm settle
        
        echo "Clearing partition table with sgdisk..."
        sgdisk --zap-all "$DRIVE"

        echo "Forcing kernel to reread partition table..."
        blockdev --rereadpt "$DRIVE" || true
        partprobe "$DRIVE" || true
    done < "/tmp/diskid_check_${pool}.txt"
}

partitionsFunc() {
    while IFS= read -r diskidnum; do
        DRIVE="/dev/disk/by-id/${diskidnum}"
        echo "Creating partitions on disk ${diskidnum} using sequential layout."
        
        # Label Initialization
        parted -s "$DRIVE" mklabel gpt
        
        CURRENT=1 # Start at 1MB for alignment
        
        add_part() {
            local name="$1"
            local size_raw="$2"
            local type="$3"
            local size_mib
            local end
            
            if [ "$size_raw" = "0" ] || [ "$size_raw" = "max" ]; then
                end="100%"
            else
                # Parse suffix and convert to MiB
                if [[ "$size_raw" =~ ^([0-9]+)([GgMmTt])$ ]]; then
                    local val="${BASH_REMATCH[1]}"
                    local unit="${BASH_REMATCH[2]}"
                    case "${unit,,}" in
                        g) size_mib=$((val * 1024)) ;;
                        t) size_mib=$((val * 1024 * 1024)) ;;
                        m) size_mib=$val ;;
                    esac
                elif [[ "$size_raw" =~ ^[0-9]+$ ]]; then
                    size_mib="$size_raw"
                else
                    echo "Error: Invalid partition size format: $size_raw"
                    exit 1
                fi
                end="$((CURRENT + size_mib))MiB"
            fi
            
            echo "Adding partition: $name ($CURRENT MiB to $end)"
            parted -s "$DRIVE" mkpart "$name" "${CURRENT}MiB" "$end"
            
            if [ "$end" != "100%" ]; then
                CURRENT=$((CURRENT + size_mib))
            fi
        }

        # 1: EFI System Partition (512MB)
        add_part "EFI" 512 "EF00"
        
        # 2: ZFS Root (Size from config)
        add_part "ZFS" "$zfs_root_size" "BF01"
        
        # 3: Unmanaged Space (Remainder)
        add_part "DATA" "max" "8300"
        
    done < "/tmp/diskid_check_root.txt"
    partprobe
    sleep 2
}
identify_existing_esp() {
    echo "Identifying disks and ESPs for pool $RPOOL..."
    true > /tmp/diskid_check_root.txt

    # Parse zpool status to find devices
    # We use -P to get full paths, -L might resolve links but we want persistent IDs if possible
    # Actually, zpool list -v -P -H is good.
    
   zpool list -v -P -H "$RPOOL" | awk '/^\t\/dev\//{print $1}' | while read -r device_path; do
        # Remove partition suffix if present (standard formats: -partX, pX for nvme, or just number for sdX)
        # We assume the input is a partition because root pools usually use partitions.
        
        parent_disk=""
        
        # Check if it's a by-id path
        if [[ "$device_path" == *"/by-id/"* ]]; then
             # Remove -part* suffix
             parent_disk="${device_path%-part*}"
             
             # Handle NVMe style if by-id naming includes it (rare for by-id, usually wwn-...)
             # but check just in case it didn't match -part*
             if [[ "$parent_disk" == "$device_path" ]]; then
                 # Try removing p[0-9]+ suffix?
                  parent_disk="${device_path%p[0-9]*}"
             fi
             
        else
            # maps to /dev/sdX or /dev/nvme0n1pX
            # resolve to by-id
            # This is complex, so let's try to map the partition to a disk by-id
            
            # Get the disk name (e.g. sda, nvme0n1)
            # lsblk -no pkname $device_path
            disk_name=$(lsblk -no pkname "$device_path" | head -n1)
            
            if [ -n "$disk_name" ]; then
                # Find a by-id link for this disk
                # Prefer ata-* or scsi-* over wwn-* for readability, but wwn is fine.
                by_id_path=$(find /dev/disk/by-id -lname "*/$disk_name" | grep -v "wwn-" | grep -v "part" | head -n1)
                
                if [ -z "$by_id_path" ]; then
                     # If no non-wwn, take any
                     by_id_path=$(find /dev/disk/by-id -lname "*/$disk_name" | grep -v "part" | head -n1)
                fi
                
                if [ -n "$by_id_path" ]; then
                    parent_disk="$by_id_path"
                fi
            fi
        fi
        
        if [ -n "$parent_disk" ]; then
            disk_id=$(basename "$parent_disk")
            echo "Found disk ID: $disk_id"
            echo "$disk_id" >> /tmp/diskid_check_root.txt
        else
            echo "Warning: Could not determine parent disk for $device_path"
        fi
    done
    
    if [ ! -s /tmp/diskid_check_root.txt ]; then
         # Fallback: try parsing `zpool status` if `zpool list` failed or gave unexpected output
         echo "Attempting fallback disk detection..."
         zpool status -P "$RPOOL" | grep "ONLINE" | grep "/dev/" | awk '{print $1}' | while read -r device_path; do
             # Same logic... simplified
             disk_name=$(lsblk -no pkname "$device_path" | head -n1)
             if [ -n "$disk_name" ]; then
                by_id_path=$(find /dev/disk/by-id -lname "*/$disk_name" | grep -v "wwn-" | grep -v "part" | head -n1)
                if [ -n "$by_id_path" ]; then
                    echo "$(basename "$by_id_path")" >> /tmp/diskid_check_root.txt
                fi
             fi
         done
    fi

    if [ ! -s /tmp/diskid_check_root.txt ]; then
        echo "Error: Could not identify underlying disks for pool $RPOOL!"
        exit 1
    fi
}
